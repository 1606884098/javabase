package base.java3oop.oop1notion.InnerClass;

/**
 * what: 在类的内部或者方法的内部的用于描述事物的类
 * 分类：
 * 1.成员内部类:类是用来模拟一个事物的，如果一个事物内部包好另外一个事物，那么一个类内部包含了另外一个类（内部类）。
 * 例如：人体和心脏的关系，汽车和发动机的关系
 * 成员内部类的定义格式：
 * 修饰符 class 外部类名称{
 *     修饰符 class 内部类名称{
 *         //...
 *     }
 *     //..
 * }
 * 注意：内部访问外部，随意访问；外部访问内部，需要通过内部类对象。
 *
 *
 * 2.局部内部类（包含了匿名内部类）：如果一个类定义在一个方法的内部，那就是局部内部类。
 * 局部：只有当前所属的方法才能使用它，出了这个方法就不能用了。
 * 2.1局部内部类的定义格式：
 * 修饰符 class 外部类名称{
 *     修饰符 返回值类型 外部类方法名称(参数列表){
 *         修饰符 class 内部类名称{
 *             //..
 *         }
 *     }
 *     //..
 * }
 * 2.2匿名内部类
 * 如果接口的实现类（或者是父类的子类）只需要使用一次，那么这种情况下就可以省略该类的定义
 * 而使用匿名内部类。
 * 匿名内部类的定义格式：
 * 接口名称 对象名称=new 接口名称（）{
 *     //重写所有抽象方法。
 * }
 * 分析：
 * 1.new代表创建对象的动作
 * 2.接口名称就是匿名内部类需要实现的那个接口
 * 3.{//重写所有抽象方法。}这才是匿名内部类的内容
 * why:
 *
 * where:
 *
 * how:
 * 1.如何使用成员内部类
 * 两种方式：
 * 1.1 间接方式：在外部类方法中使用内部类（通过在外部类方法创建内部类对象，
 * 然后再调用外部类的方法）
 * 1.2 直接方式：外部类.内部类 对象名称=new 外部类().new 内部类();
 * 内部类的变量访问：如果出现了重名现象，内部类要访问外部类的成员变量方式：外部类.this.成员变量
 *
 * 2.如何使用局部内部类
 * 2.1只有当前所属的方法才能使用它，出了这个方法就不能用了。所以只有在方法内部创建对象然后调用
 *
 * 2.2匿名内部类
 * 匿名内部类，在创建对象的时候只能使用唯一一次，不能重复使用。
 * 如果希望多次创建，并且内容一致，那必须单独定义实现类。
 * 匿名对象，在方法调用时只能使用唯一一次。
 * 如果希望一个对象，调用多次这个对象的方法，那么给对象命名。
 * 匿名内部类是省略了实现类或子类名称，但是匿名对象是省略了对象名称。匿名内部类和匿名对象不是一回事
 * 小结：
 * 1.修饰符
 * public>protected>(default)>private
 * 外部类：public/default
 * 内部类:public/protected/(default)/private
 * 局部内部类:什么也不写，不是default
 *
 * 2.局部变量的final问题
 * 局部内部类，如果访问所在的方法的局部变量，那么这个局部变量必须是有效final,也就是说是常量。（java1.8以后，final省略不写）
 *原因：new出来的对象在堆中，局部变量在栈中，方法运行结束，出栈，局部变量消失，new的对象还在堆中
 * 直到垃圾回收，所以jvm规定将局部变量的用final修饰放在常量池
 *
 */
public class InnerClass {
    public static void main(String[] args) {
        /*
        1.成员内部类:
         */
        Body body=new Body();
        body.methodBody();//1.间接方式：

        Body.Heart heart=new Body().new Heart();
        heart.beat();//2.直接方式
        heart.variable();//内部类的变量访问
        /*
        2.局部内部类:
         */
        body.partClass();//局部内部类的使用，只有当前所属的方法才能使用它，出了这个方法就不能用了。所以只有在方法内部创建对象然后调用
        /*
        3.匿名内部类:
         */
        Ianonymous ianonymous=new Ianonymous() {
            @Override
            public void method() {
                System.out.println("匿名内部类的实现方法！");
            }
        };//这样可以省掉一个实现类的单独定义
        ianonymous.method();
        //使用匿名内部类和匿名对象
        new Ianonymous() {
            @Override
            public void method() {
                System.out.println("匿名内部类的实现方法！");
            }
        }.method();
    }
}
